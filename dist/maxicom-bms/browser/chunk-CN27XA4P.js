import{a as E}from"./chunk-QAKHC542.js";import{r as P,s as D}from"./chunk-7DJ2AMDO.js";import{B as d,F as $,T as S,Z as I,ca as A,g as y,k as c,l as u,p as l,q as k,v as m,z as N}from"./chunk-4XLDPXVN.js";import{a as f,b as v}from"./chunk-C6Q5SG76.js";var T=[9600,19200,38400,57600,115200],O=[5,6,7,8],B=[1,1.5,2],R=["PARITY_NONE","PARITY_EVEN","PARITY_ODD","PARITY_MARK","PARITY_SPACE"];var C=[{id:"eth0",name:"Eth1",ipAddress:null,subnetMask:null,gateway:null,dns:null,dhcp:!0},{id:"eth1",name:"Eth2",ipAddress:null,subnetMask:null,gateway:null,dns:null,dhcp:!1}],M=class w{constructor(t,e){this.http=t;this.configService=e;this.allPortDefinitions=this.configService.serialPorts,this.loadCacheFromStorage(),this.lastKnownPorts.length>0&&(console.log("[Serial] Emitting cached ports immediately"),this.configuredPortsSubject.next(this.lastKnownPorts)),this.loadInitialPorts()}BASE_URL="/api";latestValueApiUrl="/api/latest-value";networkApiUrl="/api/network";networkRestApiUrl="/api/network";BAUD_RATES=T;DATA_BITS=O;STOP_BITS=B;PARITIES=R;allPortDefinitions=[];configuredPortsSubject=new y([]);isLoadingPorts=new y(!0);CACHE_KEY="maxicom-serial-ports-cache";lastKnownPorts=[];getFriendlyInterfaceName(t,e,r){let n=C.find(i=>i.id===t);return n?n.name:e&&/^eth\d+$/i.test(e)?e:r!==void 0?`Eth${r+1}`:e||t}normalizeDnsValue(t){if(Array.isArray(t)){let e=t.map(r=>r?.trim()).filter(Boolean);return e.length?e.join(","):null}if(typeof t=="string"){let e=t.trim();return e.length?e:null}return null}isDhcpMode(t){return t?t.trim().toLowerCase()==="dhcp":!1}loadCacheFromStorage(){try{let t=localStorage.getItem(this.CACHE_KEY);t&&(this.lastKnownPorts=JSON.parse(t),console.log(`[Serial] Loaded ${this.lastKnownPorts.length} ports from cache`))}catch(t){console.error("[Serial] Error loading cache from localStorage:",t),this.lastKnownPorts=[]}}saveCacheToStorage(t){try{localStorage.setItem(this.CACHE_KEY,JSON.stringify(t)),console.log(`[Serial] Saved ${t.length} ports to cache`)}catch(e){console.error("[Serial] Error saving cache to localStorage:",e)}}loadInitialPorts(){if(console.log("[Serial] Starting to load initial ports from backend..."),this.allPortDefinitions.length===0){console.warn("[Serial] No port definitions found in config"),this.isLoadingPorts.next(!1),this.configuredPortsSubject.next([]);return}console.log(`[Serial] Found ${this.allPortDefinitions.length} port definitions:`,this.allPortDefinitions.map(t=>`${t.alias} (${t.channel})`)),this.loadPortsFromLatestValue().pipe(S(t=>t.length>0?(console.log("[Serial] Loaded serial ports from latest-value service"),c(t)):(console.log("[Serial] Latest-value service returned no data, falling back to OpenMUC channels..."),this.fetchPortsFromChannels())),d(t=>(console.error("[Serial] Error loading serial ports from backend:",t),c([])))).subscribe(t=>{this.handlePortsLoaded(t)})}loadPortsFromLatestValue(){return this.http.get(`${this.latestValueApiUrl}/dev`).pipe(l(t=>!t?.success||!t.data?{}:t.data),l(t=>this.allPortDefinitions.map(r=>{let n=t[r.channel];return typeof n!="string"||n.trim()===""?null:this.parsePortConfig(r,n)}).filter(r=>r!==null)),d(t=>(console.warn("[Serial] Latest-value dev endpoint failed, using fallback.",t),c([]))))}fetchPortsFromChannels(){let t=this.allPortDefinitions.map(e=>this.apiGetSerialChannel(e.channel).pipe(l(r=>{if(console.log(`[Serial] API response for ${e.alias} (${e.channel}):`,r),!r)return console.warn(`[Serial] Empty response for ${e.alias}`),null;let n=r?.record?.value;if(n&&typeof n=="string"&&n.trim()!==""){let i=this.parsePortConfig(e,n);return i?console.log(`[Serial] \u2713 Successfully loaded ${e.alias} (${i.port})`):console.warn(`[Serial] \u2717 Failed to parse ${e.alias}. Settings:`,n),i}return console.log(`[Serial] No settings found for ${e.alias} (empty or invalid). Response:`,r),null}),d(r=>(console.error(`[Serial] Error fetching channel ${e.channel} for ${e.alias}:`,r),c(null)))));return m(t).pipe(l(e=>e.filter(r=>r!==null)))}handlePortsLoaded(t){if(t.length===0){console.warn("[Serial] No ports loaded from backend. Falling back to cache if available."),this.lastKnownPorts.length>0?(console.log("[Serial] Using cached port data"),this.configuredPortsSubject.next(this.lastKnownPorts)):(this.configuredPortsSubject.next([]),this.saveCacheToStorage([])),this.isLoadingPorts.next(!1);return}if(console.log(`[Serial] Loaded ${t.length}/${this.allPortDefinitions.length} ports from backend:`,t.map(e=>`${e.alias} (${e.port})`)),t.length<this.allPortDefinitions.length&&this.lastKnownPorts.length>0){console.log("[Serial] Some ports missing from backend, merging with cached data...");let e=[];this.allPortDefinitions.forEach(r=>{let n=t.find(i=>i.id===r.id);if(n)e.push(n);else{let i=this.lastKnownPorts.find(s=>s.id===r.id);i&&(console.log(`[Serial] Using cached data for ${r.alias}`),e.push(i))}}),e.length>t.length?(console.log(`[Serial] Using ${e.length} ports (${t.length} from API + ${e.length-t.length} from cache)`),this.emitPorts(e)):this.emitPorts(t)}else this.emitPorts(t);this.isLoadingPorts.next(!1)}emitPorts(t){this.configuredPortsSubject.next(t),this.lastKnownPorts=t,this.saveCacheToStorage(t)}parsePortConfig(t,e){if(!e||typeof e!="string"||e.trim()==="")return console.log(`[Serial] Empty settings for ${t.alias} (${t.channel})`),null;try{let r=e.match(/^([^:]+):/),n=r?r[1]:t.devicePath;r||console.warn(`[Serial] Could not extract device path from settings, using config default: ${t.devicePath}`);let i=/:(\d+):DATABITS_(\d):([A-Z_]+):STOPBITS_([\d_]+):/,s=e.match(i);if(!s||s.length<5)return console.warn(`[Serial] Could not parse settings for ${t.alias}. Settings:`,e),null;let o=parseInt(s[1],10),a=parseInt(s[2],10),p=s[3],g=s[4].replace("_","."),h=parseFloat(g);if(isNaN(o)||isNaN(a)||isNaN(h))return console.error(`[Serial] Invalid numeric values for ${t.alias}:`,{baudRate:o,dataBits:a,stopBits:h}),null;let b={id:t.id,alias:t.alias,port:n,channel:t.channel,baudRate:o,dataBits:a,parity:p,stopBits:h};return console.log(`[Serial] Successfully parsed ${t.alias}:`,b),b}catch(r){return console.error(`[Serial] Error parsing settings for ${t.alias}:`,r,"Settings:",e),null}}getSerialPortsConfig(){return this.isLoadingPorts.value?k([this.configuredPortsSubject,this.isLoadingPorts]).pipe(N(([t,e])=>!e),l(([t])=>t),$(1)):c(this.configuredPortsSubject.value)}getSerialPortsStream(){return this.configuredPortsSubject.asObservable()}getPortsLoadingStatus(){return this.isLoadingPorts.asObservable()}getAllPortDefinitions(){return[...this.allPortDefinitions]}addSerialPort(t){let e;if(t.portId)return e=this.allPortDefinitions.find(r=>r.id===t.portId),e?this.apiGetSerialChannel(e.channel).pipe(S(r=>{let n=r?.record?.value;return n&&typeof n=="string"&&n.trim()!==""?u(()=>new P({status:409,error:{message:"This port is already configured"}})):this.doAddSerialPort(e,t)}),d(r=>r instanceof P&&r.status===409?u(()=>r):this.doAddSerialPort(e,t))):u(()=>new P({status:400,error:{message:"Selected port not found"}}));{let r=this.allPortDefinitions.map(n=>this.apiGetSerialChannel(n.channel).pipe(l(i=>{let s=i?.record?.value;return s&&typeof s=="string"&&s.trim()!==""?null:n}),d(()=>c(n))));return m(r).pipe(S(n=>(e=n.find(i=>i!==null)||void 0,e?this.doAddSerialPort(e,t):u(()=>new P({status:400,error:{message:"The maximum limit of 3 ports has been reached"}})))))}}doAddSerialPort(t,e){let r=v(f({},e),{id:t.id,alias:t.alias,port:t.devicePath,channel:t.channel});return console.log(`[Serial] Adding new port ${r.alias}:`,r),this.apiPutSerialChannel(r.channel,r).pipe(l(()=>{let n=[...this.configuredPortsSubject.value];return n.push(r),n.sort((i,s)=>i.alias.localeCompare(s.alias)),this.configuredPortsSubject.next(n),this.lastKnownPorts=n,this.saveCacheToStorage(n),console.log(`[Serial] \u2713 Successfully added ${r.alias}`),r}),d(n=>(console.error(`[Serial] \u2717 Error adding ${r.alias}:`,n),u(()=>n))))}updateSerialPort(t,e){let r=[...this.configuredPortsSubject.value],n=r.findIndex(s=>s.id===t);if(n===-1)return u(()=>new Error("Port not found"));let i=v(f(f({},r[n]),e),{port:r[n].port,id:r[n].id,alias:r[n].alias,channel:r[n].channel});return console.log(`[Serial] Updating port ${i.alias}:`,i),this.apiPutSerialChannel(i.channel,i).pipe(l(()=>(r[n]=i,this.configuredPortsSubject.next(r),this.lastKnownPorts=r,this.saveCacheToStorage(r),console.log(`[Serial] \u2713 Successfully updated ${i.alias}`),i)),d(s=>(console.error(`[Serial] \u2717 Error updating ${i.alias}:`,s),u(()=>s))))}deleteSerialPort(t){let e=this.configuredPortsSubject.value.find(r=>r.id===t);return e?this.apiPutSerialChannel(e.channel,null).pipe(l(()=>{let r=this.configuredPortsSubject.value.filter(n=>n.id!==t);this.configuredPortsSubject.next(r),this.lastKnownPorts=r,this.saveCacheToStorage(r)})):u(()=>new Error("Port not found"))}buildModbusSettingsString(t){let e=t.stopBits.toString().replace(".","_");return`${t.port}:RTU:SERIAL_ENCODING_RTU:${t.baudRate}:DATABITS_${t.dataBits}:${t.parity}:STOPBITS_${e}:ECHO_FALSE:FLOWCONTROL_NONE:FLOWCONTROL_NONE`}apiPutSerialChannel(t,e){let r="";e&&(r=this.buildModbusSettingsString(e));let n={record:{flag:"VALID",value:r}};return this.http.put(`${this.BASE_URL}/channels/${t}`,n).pipe(d(i=>(console.error("Error on PUT Serial Channel:",i),u(()=>new Error("Could not save Serial Port configuration to server")))))}apiGetSerialChannel(t){return this.http.get(`${this.BASE_URL}/channels/${t}`)}getNetworkConfigs(){return this.fetchNetworkList().pipe(S(t=>{let e=t.interfaces||[];if(e.length>0&&e[0].mode!==void 0)return c(e.map((n,i)=>{let s=n.addresses?.find(p=>/^\d+\.\d+\.\d+\.\d+$/.test(p))||n.ipAddress||null,o=this.getFriendlyInterfaceName(n.name,n.displayName,i),a=this.normalizeDnsValue(n.dns);return{id:n.name,name:o,ipAddress:s,subnetMask:n.subnetMask||null,gateway:n.gateway||null,dns:a,dhcp:this.isDhcpMode(n.mode)}}));if(e.length===0)return c([]);let r=e.map((n,i)=>{let s=encodeURIComponent(n.name),o=this.getFriendlyInterfaceName(n.name,n.displayName,i);return this.http.get(`${this.networkRestApiUrl}/${s}`).pipe(l(a=>{let p=n.addresses?.find(b=>/^\d+\.\d+\.\d+\.\d+$/.test(b))||a.ipAddress||null,g=this.normalizeDnsValue(a.dns??n.dns),h=a.mode??n.mode??(p?"static":"dhcp");return{id:n.name,name:o,ipAddress:p,subnetMask:a.subnetMask||null,gateway:a.gateway||null,dns:g,dhcp:this.isDhcpMode(h)}}),d(a=>{console.warn(`Failed to get config for ${n.name}, using basic info:`,a);let p=n.addresses?.find(h=>/^\d+\.\d+\.\d+\.\d+$/.test(h))||null,g=this.normalizeDnsValue(n.dns);return c({id:n.name,name:o,ipAddress:p,subnetMask:null,gateway:null,dns:g,dhcp:this.isDhcpMode(n.mode)||!p})}))});return m(r)}),d(t=>(console.error("Error getting Network Configs from OpenMUC API:",t),this.fetchInterfacesByIds(C.map(e=>e.id)).pipe(S(e=>e.length>0?c(e):this.fetchLegacyNetworkConfigs()),d(e=>(console.error("Error getting Network Configs from individual fallback interfaces:",e),this.fetchLegacyNetworkConfigs()))))))}saveNetworkConfig(t){let e=encodeURIComponent(t.id),r;return t.dhcp?r={mode:"dhcp"}:(r={mode:"static",ipAddress:t.ipAddress||"",subnetMask:t.subnetMask||"",gateway:t.gateway||""},t.dns&&t.dns.trim()&&(r.dns=t.dns.trim())),this.http.put(`${this.networkRestApiUrl}/${e}`,r).pipe(l(n=>({id:n.interface,name:t.name,ipAddress:n.applied.ipAddress,subnetMask:n.applied.subnetMask,gateway:n.applied.gateway,dns:t.dns||null,dhcp:this.isDhcpMode(n.mode)})),d(n=>{console.error("Error saving Network Config to OpenMUC API:",n);let i=`${this.networkApiUrl}/config/${t.id}`,s=v(f({},t),{isDhcp:t.dhcp});return this.http.put(i,s).pipe(l(o=>this.normalizeNetworkConfig(o?.config??t)),d(o=>(console.warn("Failed to save Network Config (using local data):",o),c(this.normalizeNetworkConfig(t)))))}))}normalizeNetworkConfig(t){let e=t??{};return{id:e.id??"",name:e.name??"",ipAddress:e.ipAddress??null,subnetMask:e.subnetMask??null,gateway:e.gateway??null,dns:e.dns??null,dhcp:typeof e.isDhcp=="boolean"?e.isDhcp:(this.isDhcpMode(e.mode)||e.dhcp)??!1}}fetchInterfacesByIds(t){if(!t.length)return c([]);let e=t.map((r,n)=>{let i=encodeURIComponent(r);return this.http.get(`${this.networkRestApiUrl}/${i}`).pipe(l(s=>{let o=this.getFriendlyInterfaceName(r,s.displayName??s.name,n),a=s.ipAddress||s.addresses?.find(g=>/^\d+\.\d+\.\d+\.\d+$/.test(g))||null,p=this.normalizeDnsValue(s.dns);return{id:r,name:o,ipAddress:a,subnetMask:s.subnetMask??null,gateway:s.gateway??null,dns:p,dhcp:this.isDhcpMode(s.mode)}}),d(s=>{console.warn(`Failed to load interface ${r} directly:`,s);let o=C.find(a=>a.id===r);return c(o?f({},o):null)}))});return m(e).pipe(l(r=>r.filter(n=>n!==null)))}fetchLegacyNetworkConfigs(){return this.http.get(`${this.networkApiUrl}/configs`).pipe(l(t=>(t?.configs??[]).map(e=>this.normalizeNetworkConfig(e))),d(t=>(console.error("Error getting Network Configs from fallback API:",t),c(C.map(e=>f({},e))))))}fetchNetworkList(){return this.http.get(this.networkRestApiUrl,{responseType:"text"}).pipe(l(t=>this.parseJsonSafely(t)))}parseJsonSafely(t){let e=[t,t.replace(/,\s*,/g,","),t.replace(/,\s*,/g,",").replace(/,\s*]/g,"]").replace(/,\s*}/g,"}")];for(let r of e)try{return JSON.parse(r)}catch{continue}throw new Error("Unable to parse network response JSON")}static \u0275fac=function(e){return new(e||w)(A(D),A(E))};static \u0275prov=I({token:w,factory:w.\u0275fac,providedIn:"root"})};export{M as a};
