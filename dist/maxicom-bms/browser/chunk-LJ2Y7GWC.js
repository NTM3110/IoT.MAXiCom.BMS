import{a as I}from"./chunk-QAKHC542.js";import{r as u,s as E}from"./chunk-7DJ2AMDO.js";import{B as l,F as w,T as p,Z as T,ca as b,g as v,k as c,l as n,p as s,q as A,v as m,z as y}from"./chunk-4XLDPXVN.js";import{a as h,b as P}from"./chunk-C6Q5SG76.js";var $=[9600,19200,38400,57600,115200],O=[5,6,7,8],B=[1,1.5,2],R=["PARITY_NONE","PARITY_EVEN","PARITY_ODD","PARITY_MARK","PARITY_SPACE"];var D=class g{constructor(t,r){this.http=t;this.configService=r;this.allPortDefinitions=this.configService.serialPorts,this.loadCacheFromStorage(),this.lastKnownPorts.length>0&&(console.log("[Serial] Emitting cached ports immediately"),this.configuredPortsSubject.next(this.lastKnownPorts)),this.loadInitialPorts()}BASE_URL="/api";latestValueApiUrl="/api/latest-value";NETWORK_API="/api/network";BAUD_RATES=$;DATA_BITS=O;STOP_BITS=B;PARITIES=R;allPortDefinitions=[];configuredPortsSubject=new v([]);isLoadingPorts=new v(!0);CACHE_KEY="maxicom-serial-ports-cache";lastKnownPorts=[];loadCacheFromStorage(){try{let t=localStorage.getItem(this.CACHE_KEY);t&&(this.lastKnownPorts=JSON.parse(t),console.log(`[Serial] Loaded ${this.lastKnownPorts.length} ports from cache`))}catch(t){console.error("[Serial] Error loading cache from localStorage:",t),this.lastKnownPorts=[]}}saveCacheToStorage(t){try{localStorage.setItem(this.CACHE_KEY,JSON.stringify(t)),console.log(`[Serial] Saved ${t.length} ports to cache`)}catch(r){console.error("[Serial] Error saving cache to localStorage:",r)}}loadInitialPorts(){if(console.log("[Serial] Starting to load initial ports from backend..."),this.allPortDefinitions.length===0){console.warn("[Serial] No port definitions found in config"),this.isLoadingPorts.next(!1),this.configuredPortsSubject.next([]);return}console.log(`[Serial] Found ${this.allPortDefinitions.length} port definitions:`,this.allPortDefinitions.map(t=>`${t.alias} (${t.channel})`)),this.loadPortsFromLatestValue().pipe(p(t=>t.length>0?(console.log("[Serial] Loaded serial ports from latest-value service"),c(t)):(console.log("[Serial] Latest-value service returned no data, falling back to OpenMUC channels..."),this.fetchPortsFromChannels())),l(t=>(console.error("[Serial] Error loading serial ports from backend:",t),c([])))).subscribe(t=>{this.handlePortsLoaded(t)})}loadPortsFromLatestValue(){return this.http.get(`${this.latestValueApiUrl}/dev`).pipe(s(t=>!t?.success||!t.data?{}:t.data),s(t=>this.allPortDefinitions.map(e=>{let i=t[e.channel];return typeof i!="string"||i.trim()===""?null:this.parsePortConfig(e,i)}).filter(e=>e!==null)),l(t=>(console.warn("[Serial] Latest-value dev endpoint failed, using fallback.",t),c([]))))}fetchPortsFromChannels(){let t=this.allPortDefinitions.map(r=>this.apiGetSerialChannel(r.channel).pipe(s(e=>{if(console.log(`[Serial] API response for ${r.alias} (${r.channel}):`,e),!e)return console.warn(`[Serial] Empty response for ${r.alias}`),null;let i=e?.record?.value;if(i&&typeof i=="string"&&i.trim()!==""){let o=this.parsePortConfig(r,i);return o?console.log(`[Serial] \u2713 Successfully loaded ${r.alias} (${o.port})`):console.warn(`[Serial] \u2717 Failed to parse ${r.alias}. Settings:`,i),o}return console.log(`[Serial] No settings found for ${r.alias} (empty or invalid). Response:`,e),null}),l(e=>(console.error(`[Serial] Error fetching channel ${r.channel} for ${r.alias}:`,e),c(null)))));return m(t).pipe(s(r=>r.filter(e=>e!==null)))}handlePortsLoaded(t){if(t.length===0){console.warn("[Serial] No ports loaded from backend. Falling back to cache if available."),this.lastKnownPorts.length>0?(console.log("[Serial] Using cached port data"),this.configuredPortsSubject.next(this.lastKnownPorts)):(this.configuredPortsSubject.next([]),this.saveCacheToStorage([])),this.isLoadingPorts.next(!1);return}if(console.log(`[Serial] Loaded ${t.length}/${this.allPortDefinitions.length} ports from backend:`,t.map(r=>`${r.alias} (${r.port})`)),t.length<this.allPortDefinitions.length&&this.lastKnownPorts.length>0){console.log("[Serial] Some ports missing from backend, merging with cached data...");let r=[];this.allPortDefinitions.forEach(e=>{let i=t.find(o=>o.id===e.id);if(i)r.push(i);else{let o=this.lastKnownPorts.find(a=>a.id===e.id);o&&(console.log(`[Serial] Using cached data for ${e.alias}`),r.push(o))}}),r.length>t.length?(console.log(`[Serial] Using ${r.length} ports (${t.length} from API + ${r.length-t.length} from cache)`),this.emitPorts(r)):this.emitPorts(t)}else this.emitPorts(t);this.isLoadingPorts.next(!1)}emitPorts(t){this.configuredPortsSubject.next(t),this.lastKnownPorts=t,this.saveCacheToStorage(t)}parsePortConfig(t,r){if(!r||typeof r!="string"||r.trim()==="")return console.log(`[Serial] Empty settings for ${t.alias} (${t.channel})`),null;try{let e=r.match(/^([^:]+):/),i=e?e[1]:t.devicePath;e||console.warn(`[Serial] Could not extract device path from settings, using config default: ${t.devicePath}`);let o=/:(\d+):DATABITS_(\d):([A-Z_]+):STOPBITS_([\d_]+):/,a=r.match(o);if(!a||a.length<5)return console.warn(`[Serial] Could not parse settings for ${t.alias}. Settings:`,r),null;let d=parseInt(a[1],10),S=parseInt(a[2],10),_=a[3],N=a[4].replace("_","."),f=parseFloat(N);if(isNaN(d)||isNaN(S)||isNaN(f))return console.error(`[Serial] Invalid numeric values for ${t.alias}:`,{baudRate:d,dataBits:S,stopBits:f}),null;let C={id:t.id,alias:t.alias,port:i,channel:t.channel,baudRate:d,dataBits:S,parity:_,stopBits:f};return console.log(`[Serial] Successfully parsed ${t.alias}:`,C),C}catch(e){return console.error(`[Serial] Error parsing settings for ${t.alias}:`,e,"Settings:",r),null}}getSerialPortsConfig(){return this.isLoadingPorts.value?A([this.configuredPortsSubject,this.isLoadingPorts]).pipe(y(([t,r])=>!r),s(([t])=>t),w(1)):c(this.configuredPortsSubject.value)}getSerialPortsStream(){return this.configuredPortsSubject.asObservable()}getPortsLoadingStatus(){return this.isLoadingPorts.asObservable()}getAllPortDefinitions(){return[...this.allPortDefinitions]}addSerialPort(t){let r;if(t.portId)return r=this.allPortDefinitions.find(e=>e.id===t.portId),r?this.apiGetSerialChannel(r.channel).pipe(p(e=>{let i=e?.record?.value;return i&&typeof i=="string"&&i.trim()!==""?n(()=>new u({status:409,error:{message:"This port is already configured"}})):this.doAddSerialPort(r,t)}),l(e=>e instanceof u&&e.status===409?n(()=>e):this.doAddSerialPort(r,t))):n(()=>new u({status:400,error:{message:"Selected port not found"}}));{let e=this.allPortDefinitions.map(i=>this.apiGetSerialChannel(i.channel).pipe(s(o=>{let a=o?.record?.value;return a&&typeof a=="string"&&a.trim()!==""?null:i}),l(()=>c(i))));return m(e).pipe(p(i=>(r=i.find(o=>o!==null)||void 0,r?this.doAddSerialPort(r,t):n(()=>new u({status:400,error:{message:"The maximum limit of 3 ports has been reached"}})))))}}doAddSerialPort(t,r){let e=P(h({},r),{id:t.id,alias:t.alias,port:t.devicePath,channel:t.channel});return console.log(`[Serial] Adding new port ${e.alias}:`,e),this.apiPutSerialChannel(e.channel,e).pipe(s(()=>{let i=[...this.configuredPortsSubject.value];return i.push(e),i.sort((o,a)=>o.alias.localeCompare(a.alias)),this.configuredPortsSubject.next(i),this.lastKnownPorts=i,this.saveCacheToStorage(i),console.log(`[Serial] \u2713 Successfully added ${e.alias}`),e}),l(i=>(console.error(`[Serial] \u2717 Error adding ${e.alias}:`,i),n(()=>i))))}updateSerialPort(t,r){let e=[...this.configuredPortsSubject.value],i=e.findIndex(a=>a.id===t);if(i===-1)return n(()=>new Error("Port not found"));let o=P(h(h({},e[i]),r),{port:e[i].port,id:e[i].id,alias:e[i].alias,channel:e[i].channel});return console.log(`[Serial] Updating port ${o.alias}:`,o),this.apiPutSerialChannel(o.channel,o).pipe(s(()=>(e[i]=o,this.configuredPortsSubject.next(e),this.lastKnownPorts=e,this.saveCacheToStorage(e),console.log(`[Serial] \u2713 Successfully updated ${o.alias}`),o)),l(a=>(console.error(`[Serial] \u2717 Error updating ${o.alias}:`,a),n(()=>a))))}deleteSerialPort(t){let r=this.configuredPortsSubject.value.find(e=>e.id===t);return r?this.apiPutSerialChannel(r.channel,null).pipe(s(()=>{let e=this.configuredPortsSubject.value.filter(i=>i.id!==t);this.configuredPortsSubject.next(e),this.lastKnownPorts=e,this.saveCacheToStorage(e)})):n(()=>new Error("Port not found"))}buildModbusSettingsString(t){let r=t.stopBits.toString().replace(".","_");return`${t.port}:RTU:SERIAL_ENCODING_RTU:${t.baudRate}:DATABITS_${t.dataBits}:${t.parity}:STOPBITS_${r}:ECHO_FALSE:FLOWCONTROL_NONE:FLOWCONTROL_NONE`}apiPutSerialChannel(t,r){let e="";r&&(e=this.buildModbusSettingsString(r));let i={record:{flag:"VALID",value:e}};return this.http.put(`${this.BASE_URL}/channels/${t}`,i).pipe(l(o=>(console.error("Error on PUT Serial Channel:",o),n(()=>new Error("Could not save Serial Port configuration to server")))))}apiGetSerialChannel(t){return this.http.get(`${this.BASE_URL}/channels/${t}`)}getNetworkConfigs(){return this.http.get(this.NETWORK_API).pipe(l(t=>(console.error("Error getting network configs from Python API:",t),n(()=>t))))}saveNetworkConfig(t){let r={ipAddress:t.ipAddress,subnetMask:t.subnetMask,gateway:t.gateway,dns:t.dns,dhcp:t.dhcp};return this.http.put(`${this.NETWORK_API}/${t.id}`,r).pipe(s(e=>(console.log("Network saved successfully:",e),e)),l(e=>(console.error("Error saving network config:",e),n(()=>e))))}static \u0275fac=function(r){return new(r||g)(b(E),b(I))};static \u0275prov=T({token:g,factory:g.\u0275fac,providedIn:"root"})};export{D as a};
